from math import degrees
import numpy as np
from fenics import *
from dolfin import *
from mshr import *
from dgl.data.utils import save_graphs
from src.utils.to_dgl import to_dgl
from src.utils.bc import rectangle


def gaussian(stop:float,
             steps:int, 
             mesh, 
             f:str='0', 
             u0:str='0', 
             ud: str='0',
             path:str='data/gaussian.bin'
             ):
    ''' Create Gaussian Equation Dataset

    2D Gaussian equation, dynamic process, custom domain, 
    singel dirichlet boundary condition. 

    Args:
        stop: <float> process stop time
        steps: <int> number of time step
        mesh: <dolfin.cpp.mesh.Mesh> custom mesh generated by fenics mesh tools
        f: <str> right part of laplace function, in cpp argument format
        ud: <str> boundary condition function, in cpp argument format
        u0: <str> initialization condition function, in cpp argument format
        path: <str> path for saving generated dgl graph, in .bin format
    '''
    dt = stop / steps
    function_space = FunctionSpace(mesh, 'P', 1)
    u0 = Expression(u0, degree=2)
    ud = Expression(ud, degree=2)
    f = Expression(f, degree=2)

    bc = DirichletBC(function_space, ud, boundary)

    un = interpolate(u0, function_space)
    
    u = TrialFunction(function_space)
    v = TestFunction(function_space)
    F = u * v * dx + dt * dot(grad(u), grad(v)) * dx - (un + dt * f) * v * dx
    a, L = lhs(F), rhs(F)

    u = Function(function_space)
    t = 0
    graphs = []
    for _ in range(steps):
        t += dt
        solve(a == L, u, bc)
        un.assign(u)
        graphs.append(to_dgl(function=u, mesh=mesh))
    
    save_graphs(path, graphs)


def gaussian_square(x0:float,
                    xn:float, 
                    y0:float,
                    yn:float,
                    stop:float, 
                    steps:int, 
                    f:str='0', 
                    ud_top:str='0',
                    ud_bottom:str='0',
                    ud_left:str='0',
                    ud_right:str='0',
                    u0:str='0', 
                    cell_size:float=5.,
                    tol:float=1e-4,
                    dy:bool=False, 
                    path:str='data/gaussian_square_static.bin'
                    ):
    '''Create Gaussian Equation Dataset

    2D Gaussian equation, dynamic process, rectangle domain, 
    can custom each boundary's condition, boundary, can choose
    static boundary condition or dynamic boundary condition. 

    Args:
        x0: <float> left boundary for x
        xn: <float> right boundary for x
        y0: <float> left boundary for y
        yn: <float> right boundary for y
        stop: <float> process stop time
        steps: <int> number of time step
        f: <str> right part of laplace function, in cpp argument format
        ud_top: <str> boundary condition on the top of rectangle
        ud_bottom: <str> boundary condition on the bottom of rectangle
        ud_left: <str> boundary condition on the left of rectangle
        ud_right: <str> boundary condition on the right of rectangle
        u0: <str> initialization condition function, in cpp argument format
        cell_siez: <float> cell size for created mesh
        tol: <float> boundary bias, e.g. (x-tol, x+tol) is a boundary on x
        dy: <bool> if the boundary condition is dynamic
        path: <str> path for saving generated dgl graph, in .bin format
    '''
    if (dy):
        mesh, function_space, bc = rectangle(x0,
                                             xn, 
                                             y0, 
                                             yn, 
                                             ud_top, 
                                             ud_bottom, 
                                             ud_left,
                                             ud_right, 
                                             cell_size, 
                                             0, 
                                             tol
                                             )
    else:
        mesh, function_space, bc = rectangle(x0, 
                                             xn, 
                                             y0, 
                                             yn, 
                                             ud_top, 
                                             ud_bottom, 
                                             ud_left, 
                                             ud_right,
                                             cell_size,
                                             tol
                                             )
    dt = stop / steps  
    u0 = Expression(u0, degree=2)
    f = Expression(f, degree=2)
    un = interpolate(u0, function_space)
    
    u = TrialFunction(function_space)
    v = TestFunction(function_space)
    F = u * v * dx + dt * dot(grad(u), grad(v)) * dx - (un + dt * f) * v * dx
    a, L = lhs(F), rhs(F)

    u = Function(function_space)
    t = 0
    graphs = []
    for _ in range(steps):
        t += dt
        if (dy):
            _, bc = rectangle(x0,
                              xn, 
                              y0, 
                              yn, 
                              ud_top, 
                              ud_bottom, 
                              ud_left,
                              ud_right, 
                              cell_size, 
                              t, 
                              tol
                              )
        solve(a == L, u, bc)
        un.assign(u)
        graphs.append(to_dgl(function=u, mesh=mesh))
    
    save_graphs(path, graphs)


def boundary(x, on_boundary):
    return on_boundary